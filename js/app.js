// App.js

(function(){
    
    var app = angular.module("circleApp", [ ]);
    
    // create the circleCanvas directive to link with the HTML element
    app.directive("circleCanvas", function() {
     var directiveDefinitionObject = {
         restrict: "E",
         link: function (scope, element, attrs) {
             // call to the controller to create the circle elements
             scope.loadCircles();
         } 
      };
      return directiveDefinitionObject;
    });
    
    
    
    app.controller("circleCtrl", ["$scope", "$http", function($scope, $http){
        // local variables
        var s = $scope;
        var circleData = [];
        var circleStatus = [];
        var svgContainer;
        
        // Scope accessible variables
        s.maxRowLength = 32;
        s.cRadius = 20;
        s.cPadding = 5;
        s.tCircles = 5;
        s.inputError = false;
        
        // Contains the functions that generate the circles. Bound to the regen button
        s.loadCircles = function() {
            console.time("loading circles");
            getCircleStatusList();
            generateCanvas();
            generateCircles();
            drawCircles();
            console.timeEnd("loading circles");
        }
        
        // validates that an input is a number. If not then the regen button is disabled
        s.checkNumber = function() {
            if( isFinite( s.maxRowLength ) && isFinite( s.cRadius ) && isFinite( s.cPadding ) && isFinite( s.tCircles ) ) {
                s.inputError = false;
            }
            else {
                s.inputError = true;
            }
        }
        
        // Generate the size of the canvas based upon the circle radius, padding and the row length
        // This ensures an even canvas is drawn
        function generateCanvas(){
            const circleSpacing = s.cRadius * 2 + s.cPadding;
            const canvasWidth = circleSpacing * s.maxRowLength + s.cPadding;
            const canvasHeight = Math.ceil( s.tCircles / s.maxRowLength ) * circleSpacing + s.cPadding;
            
            if( svgContainer ) {
                svgContainer.selectAll("circle").remove();
                svgContainer.remove();
            }
            
            svgContainer = d3.select("body")
                .append("svg")
                .attr("width", canvasWidth)
                .attr("height", canvasHeight);
            
            initGradients( svgContainer );
        }
        
        // Generate tCircles circles object data into an array
        // Y is incremented when a new max row length is reached for that row
        function generateCircles( ) {
            circleData.length = 0;
            var rowCount = 0;
            var columnCount = 0;

            for( var i = 0; i < s.tCircles; i++ ) {
                if( i % s.maxRowLength == 0 ) {
                    rowCount++;
                    columnCount = 0;
                }
                columnCount++;
                
                var circleX = s.cRadius * 2 * columnCount + (s.cPadding * columnCount) - s.cRadius;
                var circleY = s.cRadius * 2 * rowCount + (s.cPadding * rowCount) - s.cRadius;
                var newCircle = { x: circleX, y: circleY, radius: s.cRadius, color: circleStatus[i].color };
                circleData.push(newCircle);
            }
        }
        
        // Using the data generated by generateCircles, draw each circle onto the canvas using d3js
        function drawCircles() {
            var displayedCircles = circleData.slice(0, s.tCircles);
            circles = svgContainer.selectAll("circle")
                .data(displayedCircles)
                .enter()
                .append("circle");

            circleAttributes = circles.attr("cx", function (d) { return d.x; })
                .attr("cy", function (d) { return d.y; })
                .attr("r", function (d) { return d.radius; })
                .style("fill", function(d) { return d.color; });
        }
        
        // Placeholder function which would contain meta circle data information.
        // Color would actually link against an error type, for example.
        // tCircles would also be based upon this array in a real world situation
        function getCircleStatusList( ) {
            circleStatus.length = 0;
            for( var i = 0; i < s.tCircles; i++ ) {
                circleStatus.push( { color: getRandomColor() } );                      
            }
        }  
        
        // Generates a random color .. 70% green, 20% yellow, 10% red
        function  getRandomColor() {
            var rNum = Math.floor((Math.random() * 100) + 1);

            //70% green, 20% yellow, 10% red
            if( rNum <= 70 ) {
               color = "url(#greenGrad)"; 
            }
            else if( rNum > 70 && rNum <= 90 ) {
                color = "url(#yellowGrad)";
            }
            else {
                color = "url(#redGrad)";
            }

            return color;
        }
        
    }]);

    // Sets the gradient colors for each of the orbs, stored as an SVG definition on the SVG container
    function initGradients( svgContainer ) {
        var greenGradient = svgContainer.append("svg:defs")
            .append("svg:linearGradient")
            .attr("id", "greenGrad")
            .attr("x1", "0%")
            .attr("y1", "0%")
            .attr("x2", "100%")
            .attr("y2", "100%")
            .attr("spreadMethod", "pad");

        greenGradient.append("svg:stop")
            .attr("offset", "0%")
            .attr("stop-color", "#BFFFCF")
            .attr("stop-opacity", 1);

        greenGradient.append("svg:stop")
            .attr("offset", "100%")
            .attr("stop-color", "#00FF40")
            .attr("stop-opacity", 1);

        var yellowGradient = svgContainer.append("svg:defs")
            .append("svg:linearGradient")
            .attr("id", "yellowGrad")
            .attr("x1", "0%")
            .attr("y1", "0%")
            .attr("x2", "100%")
            .attr("y2", "100%")
            .attr("spreadMethod", "pad");

        yellowGradient.append("svg:stop")
            .attr("offset", "0%")
            .attr("stop-color", "#FFFF9F")
            .attr("stop-opacity", 1);

        yellowGradient.append("svg:stop")
            .attr("offset", "100%")
            .attr("stop-color", "#FFFF00")
            .attr("stop-opacity", 1);

        var redGradient = svgContainer.append("svg:defs")
            .append("svg:linearGradient")
            .attr("id", "redGrad")
            .attr("x1", "0%")
            .attr("y1", "0%")
            .attr("x2", "100%")
            .attr("y2", "100%")
            .attr("spreadMethod", "pad");

        redGradient.append("svg:stop")
            .attr("offset", "0%")
            .attr("stop-color", "#FF9797")
            .attr("stop-opacity", 1);

        redGradient.append("svg:stop")
            .attr("offset", "100%")
            .attr("stop-color", "#FF0000")
            .attr("stop-opacity", 1);
    }
})(); 